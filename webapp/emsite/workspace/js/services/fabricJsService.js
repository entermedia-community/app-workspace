// Generated by CoffeeScript 1.4.0

Workspace.factory('fabricJsService', function() {
  return {
    init: function(path) {
      var returnCanvas;
      returnCanvas = {};
      (function() {
        var canvas, docGet;
        docGet = function(id) {
          return document.getElementById(id);
        };
        canvas = this.__canvas = new fabric.Canvas('annotation_canvas', {
          isDrawingMode: true
        });
        canvas.on("after:render", function() {
          canvas.calcOffset();
          return em.unit;
        });
        canvas.setBackgroundImage(path, canvas.renderAll.bind(canvas));
        /*
                    I doubt that we can even perform this logic in the factory, and it
                    belongs in a controller I assume
        */

        $scope.toolkit = [
          {
            name: 'draw',
            properties: {}
          }, {
            name: 'move',
            properties: {}
          }, {
            name: 'shape',
            properties: {},
            type: fabric.Circle,
            types: [fabric.Circle, fabric.Rect],
            blanks: [
              {
                radius: 1,
                strokeWidth: 5,
                stroke: 'red',
                selectable: false,
                fill: "",
                originX: 'center',
                originY: 'center'
              }, {
                height: 1,
                width: 1,
                strokeWidth: 5,
                stroke: 'red',
                selectable: false,
                fill: "",
                originX: 'left',
                originY: 'top'
              }
            ],
            events: {
              /*
              
                                      I don't think it makes sense to put these weird event-based props on $scope, so the implementation
                                      is bad and confusing maybe the canvas should know current shape/current tool, but when you have multiple
                                      people drawing it is hard to say without knowing more about how the canvases are deployed
                                      i.e. is it one canvas on server being manipulated or multiple canvases per user being pushed to
                                      merge with server copy
              */

              mouseup: function(canvas, o) {
                var pointer, spec;
                pointer = canvas.getPointer(o.e);
                spec = this.blanks[this.types.indexOf(this.type)];
                spec.left = pointer.x;
                spec.top = pointer.y;
                canvas.add(new this.type(spec));
                return em.unit;
              },
              mousedown: function(canvas, o) {
                var mouseDown;
                mouseDown = true;
                return em.unit;
              },
              objectadded: null,
              mousemove: function(canvas, o) {
                var pointer;
                if (mouseDown) {
                  pointer = canvas.getPointer(o.e);
                  shape.set(canvas.drawParams(pointer));
                  canvas.renderAll();
                }
                return em.unit;
              }
            }
          }, {
            name: 'comment',
            properties: {},
            events: {
              mouseup: null,
              mousedown: null,
              objectadded: null
            }
          }, {
            name: 'arrow',
            properties: {}
          }, {
            name: 'text',
            properties: {}
          }, {
            name: 'zoom',
            properties: {}
          }, {
            name: 'colorpicker',
            properties: {}
          }
        ];
        $scope.selectTool = function(toolname) {
          var tool, _i, _len, _ref;
          _ref = $scope.toolkit;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            tool = _ref[_i];
            if (tool.name === toolname) {
              $scope.currentTool = $scope.toolkit[tool];
            }
          }
          return null;
        };
        drawingColorEl.onchange = function() {
          canvas.freeDrawingBrush.color = this.value;
          return em.unit;
        };
        returnCanvas = canvas;
        return em.unit;
      })();
      (function() {
        return fabric.util.addListener(fabric.window, 'load', function() {
          var canvas, canvases, _i, _ref;
          canvas = this.__canvas || this.canvas;
          canvases = this.__canvases || this.canvases;
          canvas && canvas.calcOffset && canvas.calcOffset();
          if (canvases && canvases.length) {
            for (_i = 0, _ref = canvases.length; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--) {
              canvases[i].calcOffset();
            }
          }
          return em.unit;
        });
      })();
      return {
        canvas: returnCanvas
      };
    }
  };
});
