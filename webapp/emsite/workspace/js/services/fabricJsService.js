// Generated by CoffeeScript 1.4.0

Workspace.factory('fabricJsService', function() {
  var getSelf, toolkit;
  getSelf = function(name) {
    return _.find(toolkit, {
      name: name
    });
  };
  toolkit = [
    {
      name: 'draw',
      properties: {
        isDrawingMode: true
      }
    }, {
      name: 'move',
      properties: {}
    }, {
      name: 'shape',
      properties: {
        isDrawingMode: false
      },
      type: fabric.Circle,
      types: [fabric.Circle, fabric.Rect],
      drawparams: [
        function(pointer) {
          return {
            radius: Math.abs(self.origX - pointer.x)
          };
        }, function(pointer) {
          return {
            width: -(self.origX - pointer.x),
            height: -(self.origY - pointer.y)
          };
        }
      ],
      blanks: [
        {
          radius: 1,
          strokeWidth: 5,
          stroke: 'red',
          selectable: false,
          fill: "",
          originX: 'center',
          originY: 'center'
        }, {
          height: 1,
          width: 1,
          strokeWidth: 5,
          stroke: 'red',
          selectable: false,
          fill: "",
          originX: 'left',
          originY: 'top'
        }
      ],
      events: {
        mouseup: function(e, canvas) {
          return self.mouseDown = false;
        },
        mousedown: function(e, canvas) {
          var pointer, shape, spec, we;
          self.mouseDown = true;
          pointer = canvas.getPointer(e.e);
          we = getSelf('shape');
          spec = we.blanks[we.types.indexOf(we.type)];
          spec.left = pointer.x;
          spec.top = pointer.y;
          shape = new we.type(spec);
          canvas.add(shape);
          return em.unit;
        },
        objectadded: null,
        mousemove: function(e, canvas) {
          var pointer, shape, we;
          if (self.mouseDown) {
            we = getSelf('shape');
            pointer = canvas.getPointer(e.e);
            shape = canvas.getObjects()[canvas.getObjects().length - 1];
            console.log(shape);
            shape.set(we.drawparams[we.types.indexOf(we.type)](pointer));
            canvas.renderAll();
          }
          return em.unit;
        }
      }
    }, {
      name: 'comment',
      properties: {},
      events: {
        mouseup: null,
        mousedown: null,
        objectadded: null
      }
    }, {
      name: 'arrow',
      properties: {}
    }, {
      name: 'text',
      properties: {}
    }, {
      name: 'zoom',
      properties: {}
    }, {
      name: 'colorpicker',
      properties: {}
    }
  ];
  return {
    init: function(path) {
      var returnCanvas;
      returnCanvas = {};
      (function() {
        var canvas, docGet;
        docGet = function(id) {
          return document.getElementById(id);
        };
        canvas = this.__canvas = new fabric.Canvas('annotation_canvas', {
          isDrawingMode: true
        });
        canvas.on("after:render", function() {
          canvas.calcOffset();
          return em.unit;
        });
        canvas.setBackgroundImage(path, canvas.renderAll.bind(canvas));
        /*
                    I doubt that we can even perform this logic in the factory, and it
                    belongs in a controller I assume
        */

        returnCanvas = canvas;
        return em.unit;
      })();
      (function() {
        return fabric.util.addListener(fabric.window, 'load', function() {
          var canvas, canvases, _i, _ref;
          canvas = this.__canvas || this.canvas;
          canvases = this.__canvases || this.canvases;
          canvas && canvas.calcOffset && canvas.calcOffset();
          if (canvases && canvases.length) {
            for (_i = 0, _ref = canvases.length; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--) {
              canvases[i].calcOffset();
            }
          }
          return em.unit;
        });
      })();
      return {
        canvas: returnCanvas,
        toolkit: toolkit
      };
    }
  };
});
