// Generated by CoffeeScript 1.4.0

Workspace.controller('AnnotationDetailsCtrl', [
  '$scope', '$stateParams', '$timeout', 'annotationService', 'fabricJsService', function($scope, $stateParams, $timeout, annotationService, fabricJsService) {
    var comment, comment2, comment3, commentPin, timeoutFunc, usefulKeys;
    self.mouseDown = null;
    self.origX = 0;
    self.origY = 0;
    $scope.currentCommentIndex = 3;
    $scope.newCommentText = null;
    $scope.approvalHash = {};
    comment = {
      type: 'normal',
      name: 'Rob',
      email: md5('jrchipman1@gmail.com'),
      text: 'This is a comment that some dude left on here. cool.',
      annotationId: 3,
      timestamp: moment().fromNow()
    };
    comment2 = {
      type: 'normal',
      name: 'Chris',
      email: md5('test@gmail.com'),
      text: 'Hey, what about the thing on the right here, don\'t forget to do the stuff.',
      annotationId: 2,
      timestamp: moment().subtract('minutes', 30).fromNow()
    };
    comment3 = {
      type: 'normal',
      name: 'Adam',
      email: md5('test@gmail.com'),
      text: 'I dont feel like the sky is as blue as it could be, perhaps we should revisit?',
      annotationId: 1,
      timestamp: moment().subtract('days', 1).fromNow()
    };
    $scope.comments = [comment, comment2, comment3];
    $scope.approved = [1, 2, 3, 4];
    $scope.rejected = [1];
    $scope.images = [1, 2, 3, 4, 5, 6];
    $scope.thumbs = ['img/thumbs/BlueBus.gif', 'img/thumbs/ForMom.gif', 'img/thumbs/Baseball-Player.gif', 'img/thumbs/FenceDog.gif', 'img/thumbs/TigerTug.gif', 'img/thumbs/hs-2003-28-a-1280x768_wallpaper.gif'];
    $scope.addComment = function() {
      $scope.comments.unshift({
        type: 'normal',
        name: 'Rob',
        email: md5('jrchipman1@gmail.com'),
        text: $scope.newCommentText,
        annotationId: ++$scope.currentCommentIndex,
        timestamp: moment().fromNow()
      });
      $scope.newCommentText = null;
      return em.unit;
    };
    $scope.selectTool = function(toolname) {
      var prop;
      $scope.currentTool = _.findWhere($scope.fabric.toolkit, {
        name: toolname
      });
      for (prop in $scope.currentTool.properties) {
        $scope.fabric.canvas[prop] = $scope.currentTool.properties[prop];
      }
      console.log($scope.currentTool);
      return em.unit;
    };
    $scope.setApproval = function(user, approvalState) {
      return $scope.approvalHash[user] = approvalState;
    };
    $scope.getApprovals = function() {
      var user, _results;
      _results = [];
      for (user in $scope.approvalHash) {
        if ($scope.approvalHash[user] === true) {
          _results.push(user);
        }
      }
      return _results;
    };
    $scope.getRejections = function() {
      var user, _results;
      _results = [];
      for (user in $scope.approvalHash) {
        if ($scope.approvalHash[user] === false) {
          _results.push(user);
        }
      }
      return _results;
    };
    $scope.annotations = [];
    $scope.events = [];
    usefulKeys = [''];
    $scope.currentAnnotation = _.find(annotationService.mockData, function(item) {
      return item.annotation.id === parseInt($stateParams.annotationID);
    });
    $scope.fabric = fabricJsService.init($scope.currentAnnotation.annotation.path);
    $scope.selectTool('draw');
    $scope.eventIndex = 0;
    $scope.annotationAction = null;
    $scope.currentAnnotationGroup = [];
    $scope.currentAnnotationGroupId = 0;
    /*
        This whole process is muddled, what should happen is simple:
        user clicks to draw a shape, that shape is added to the current group upon object:added
        a timeout function begins to check if they are done annotating
        if the user clicks again within a time window, the timeout function is cancelled
        repeat process until...
        user finishes annotation, they should be prompted for a comment
        a pin should be created and added into the annotationGroup data
        the pin should be rendered on screen somewhere appropriate and...
        the comment should be added to scope with annotationGroup data to be attached to comment
    */

    commentPin = function() {
      var dropPoint;
      dropPoint = $scope.fabric.canvas.getObjects()[$scope.fabric.canvas.getObjects().length - 1];
      return new fabric.Group([
        new fabric.Circle({
          radius: 15,
          fill: "#000fff",
          borderColor: "#fff"
        }), new fabric.Text($scope.currentCommentIndex.toString(), {
          fontSize: 30,
          color: "#ffffff",
          left: 5,
          top: -5
        })
      ], {
        evented: false,
        top: dropPoint.top,
        left: dropPoint.left
      });
    };
    timeoutFunc = function() {
      var annotationSpec;
      $scope.events.push({
        id: $scope.eventIndex++,
        text: 'Object added!'
      });
      $scope.newCommentText = prompt("Enter a comment:" || "<no comment?>");
      annotationSpec = {
        id: $scope.currentCommentIndex + 1,
        group: $scope.currentAnnotationGroup,
        user: $scope.currentUser,
        comment: $scope.newCommentText
      };
      $scope.addComment();
      $scope.fabric.canvas.add(commentPin());
      $scope.annotations.push(annotationSpec);
      $scope.currentAnnotationGroup = [];
      $scope.$apply();
      return em.unit;
    };
    $scope.fabric.canvas.on('mouse:down', function(e) {
      var pointer, _ref;
      self.mouseDown = true;
      if ($scope.annotationAction !== null) {
        $timeout.cancel($scope.annotationAction);
      }
      pointer = $scope.fabric.canvas.getPointer(e.e);
      self.origX = pointer.x;
      self.origY = pointer.y;
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.mousedown === "function") {
          _ref.mousedown(e, $scope.fabric.canvas);
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('mouse:up', function(e) {
      var _ref;
      self.mouseDown = false;
      if ($scope.currentTool.annotating) {
        $scope.annotationAction = $timeout(timeoutFunc, 2000);
      }
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.mouseup === "function") {
          _ref.mouseup(e, $scope.fabric.canvas);
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('mouse:move', function(e) {
      var _ref;
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.mousemove === "function") {
          _ref.mousemove(e, $scope.fabric.canvas);
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('object:added', function(obj) {
      var _ref;
      if ($scope.currentTool.annotating) {
        $scope.currentAnnotationGroup.push(obj);
      }
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.objectadded === "function") {
          _ref.objectadded(obj, $scope.fabric.canvas);
        }
      }
      $scope.fabric.canvas.renderAll();
      $scope.fabric.canvas.calcOffset();
      return em.unit;
    });
    return em.unit;
  }
]);
